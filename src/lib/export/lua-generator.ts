import { allOptions, getOptionById, getDefaultValue } from "@/data/wezterm-options";
import type { Keybind, LaunchMenuItem } from "@/lib/schema/types";

// Convert a JavaScript value to Lua syntax
function toLua(value: unknown, indent = 0): string {
  const spaces = "  ".repeat(indent);
  
  if (value === null || value === undefined) {
    return "nil";
  }
  
  if (typeof value === "boolean") {
    return value ? "true" : "false";
  }
  
  if (typeof value === "number") {
    return String(value);
  }
  
  if (typeof value === "string") {
    // Escape special characters in Lua strings (security: prevent injection)
    const escaped = value
      .replace(/\\/g, "\\\\")
      .replace(/"/g, '\\"')
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/\t/g, "\\t")
      .replace(/\0/g, "\\0")
      // Escape other control characters as octal
      .replace(/[\x00-\x1f\x7f-\x9f]/g, (char) => {
        const code = char.charCodeAt(0);
        return `\\${code.toString(8).padStart(3, "0")}`;
      });
    return `"${escaped}"`;
  }
  
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return "{}";
    }
    const items = value.map((item) => `${spaces}  ${toLua(item, indent + 1)}`);
    return `{\n${items.join(",\n")},\n${spaces}}`;
  }
  
  if (typeof value === "object") {
    const entries = Object.entries(value as Record<string, unknown>);
    if (entries.length === 0) {
      return "{}";
    }
    const lines = entries.map(([key, val]) => {
      // Use bracket notation for keys with special characters
      const keyStr = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)
        ? key
        : `["${key}"]`;
      return `${spaces}  ${keyStr} = ${toLua(val, indent + 1)}`;
    });
    return `{\n${lines.join(",\n")},\n${spaces}}`;
  }
  
  return String(value);
}

// Convert WezTerm option ID to Lua config key
function optionIdToLuaKey(id: string): string {
  const option = getOptionById(id);
  if (option?.luaKey) {
    return option.luaKey;
  }
  // Most WezTerm options use snake_case which matches our IDs
  return id;
}

// Generate keybinding Lua code
function generateKeybindLua(keybind: Keybind): string {
  const mods = keybind.mods?.join("|") || "";
  const action = keybind.actionArgs
    ? `wezterm.action.${keybind.action}(${toLua(keybind.actionArgs)})`
    : `wezterm.action.${keybind.action}`;
    
  if (mods) {
    return `{ key = "${keybind.key}", mods = "${mods}", action = ${action} }`;
  }
  return `{ key = "${keybind.key}", action = ${action} }`;
}

// Generate launch menu item Lua code
function generateLaunchMenuItemLua(item: LaunchMenuItem): string {
  const parts: string[] = [];
  
  parts.push(`label = ${toLua(item.label)}`);
  
  if (item.args && item.args.length > 0) {
    parts.push(`args = ${toLua(item.args)}`);
  }
  
  if (item.cwd) {
    parts.push(`cwd = ${toLua(item.cwd)}`);
  }
  
  if (item.domain) {
    parts.push(`domain = { DomainName = ${toLua(item.domain)} }`);
  }
  
  if (item.set_environment_variables && Object.keys(item.set_environment_variables).length > 0) {
    parts.push(`set_environment_variables = ${toLua(item.set_environment_variables)}`);
  }
  
  return `{ ${parts.join(", ")} }`;
}

// Group options by their Lua config structure
interface GeneratorOptions {
  includeDefaults?: boolean;
  includeComments?: boolean;
}

export function generateLuaConfig(
  config: Record<string, unknown>,
  options: GeneratorOptions = {}
): string {
  const { includeDefaults = false, includeComments = true } = options;
  
  const lines: string[] = [];
  
  // Header
  lines.push("-- WezTerm Configuration");
  lines.push("-- Generated by WezTerm Config Editor");
  lines.push(`-- ${new Date().toISOString().split("T")[0]}`);
  lines.push("");
  lines.push("local wezterm = require('wezterm')");
  lines.push("");
  lines.push("local config = {}");
  lines.push("");
  lines.push("-- Use config builder if available");
  lines.push("if wezterm.config_builder then");
  lines.push("  config = wezterm.config_builder()");
  lines.push("end");
  lines.push("");

  // Group options by category for organization
  const categories: Record<string, string[]> = {};
  
  for (const option of allOptions) {
    const value = config[option.id] ?? (includeDefaults ? option.default : undefined);
    
    // Skip if value is not set and we're not including defaults
    if (value === undefined) continue;
    
    // Skip if value equals default and we're not including defaults
    if (!includeDefaults && JSON.stringify(value) === JSON.stringify(option.default)) {
      continue;
    }
    
    // Handle visual_bell "Disabled" as empty string in Lua
    if (option.id === "visual_bell" && value === "Disabled") {
      // Skip - WezTerm uses empty/nil for disabled visual bell
      continue;
    }
    
    // Handle special cases
    if (option.id === "keys" && Array.isArray(value)) {
      // Keybindings need special handling
      if (!categories["keybindings"]) {
        categories["keybindings"] = [];
      }
      categories["keybindings"].push("config.keys = {");
      for (const keybind of value as Keybind[]) {
        categories["keybindings"].push(`  ${generateKeybindLua(keybind)},`);
      }
      categories["keybindings"].push("}");
      continue;
    }
    
    // Handle launch_menu
    if (option.id === "launch_menu" && Array.isArray(value) && value.length > 0) {
      if (!categories["shell"]) {
        categories["shell"] = [];
      }
      categories["shell"].push("config.launch_menu = {");
      for (const item of value as LaunchMenuItem[]) {
        categories["shell"].push(`  ${generateLaunchMenuItemLua(item)},`);
      }
      categories["shell"].push("}");
      categories["shell"].push("");
      continue;
    }
    
    // Handle color palette (ansi/brights)
    if (option.id === "ansi" || option.id === "brights") {
      if (!categories["colors"]) {
        categories["colors"] = [];
      }
      if (includeComments && option.description) {
        categories["colors"].push(`-- ${option.name}`);
      }
      // These go inside config.colors table
      continue; // We'll handle these separately
    }
    
    // Standard option
    const category = option.category;
    if (!categories[category]) {
      categories[category] = [];
    }
    
    const luaKey = optionIdToLuaKey(option.id);
    const luaValue = toLua(value);
    
    if (includeComments && option.description) {
      categories[category].push(`-- ${option.name}: ${option.description}`);
    }
    categories[category].push(`config.${luaKey} = ${luaValue}`);
    if (includeComments) {
      categories[category].push("");
    }
  }

  // Handle colors table specially (for ansi/brights palettes)
  const ansiValue = config["ansi"] ?? (includeDefaults ? getDefaultValue("ansi") : undefined);
  const brightsValue = config["brights"] ?? (includeDefaults ? getDefaultValue("brights") : undefined);
  const hasColorValues = (
    config["foreground"] || config["background"] || 
    config["cursor_bg"] || config["cursor_fg"] || config["cursor_border"] ||
    config["selection_bg"] || config["selection_fg"] ||
    ansiValue || brightsValue
  );
  
  if (hasColorValues) {
    const colorLines: string[] = [];
    colorLines.push("config.colors = {");
    
    // Individual color settings
    for (const colorKey of ["foreground", "background", "cursor_bg", "cursor_fg", "cursor_border", "selection_bg", "selection_fg"]) {
      const value = config[colorKey];
      if (value !== undefined) {
        colorLines.push(`  ${colorKey} = ${toLua(value)},`);
      }
    }
    
    // ANSI palette
    if (ansiValue && Array.isArray(ansiValue)) {
      colorLines.push("  ansi = {");
      for (const color of ansiValue as string[]) {
        colorLines.push(`    ${toLua(color)},`);
      }
      colorLines.push("  },");
    }
    
    // Bright palette
    if (brightsValue && Array.isArray(brightsValue)) {
      colorLines.push("  brights = {");
      for (const color of brightsValue as string[]) {
        colorLines.push(`    ${toLua(color)},`);
      }
      colorLines.push("  },");
    }
    
    colorLines.push("}");
    lines.push(...colorLines);
    lines.push("");
  }

  // Output categorized options (except colors which we handled above)
  const categoryOrder = ["fonts", "window", "cursor", "gpu", "general", "shell", "keybindings", "advanced"];
  
  for (const category of categoryOrder) {
    const categoryLines = categories[category];
    if (categoryLines && categoryLines.length > 0) {
      // Skip color options since we handle them separately
      if (category === "colors") continue;
      
      if (includeComments) {
        lines.push(`-- ${category.charAt(0).toUpperCase() + category.slice(1)} Settings`);
      }
      lines.push(...categoryLines);
      if (!includeComments) {
        lines.push("");
      }
    }
  }
  
  // Footer
  lines.push("return config");
  
  return lines.join("\n");
}

// Generate a downloadable file
export function downloadLuaConfig(config: Record<string, unknown>): void {
  const lua = generateLuaConfig(config, { includeComments: true });
  const blob = new Blob([lua], { type: "text/x-lua" });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement("a");
  a.href = url;
  a.download = "wezterm.lua";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Copy to clipboard
export async function copyLuaConfig(config: Record<string, unknown>): Promise<void> {
  const lua = generateLuaConfig(config, { includeComments: true });
  await navigator.clipboard.writeText(lua);
}
